---
title: "Building Full-Stack Applications with NestJS and Next.js: A Perfect Match"
date: "2024-06-22"
description: "How combining NestJS backend with Next.js frontend creates a powerful, type-safe full-stack TypeScript architecture"
tags: ["nestjs", "nextjs", "typescript", "architecture"]
---

After 27 years of building web applications with various tech stacks, I've found that the combination of NestJS and Next.js represents one of the most productive and maintainable approaches to full-stack development. Both at Servant and in my recent projects, this duo has proven invaluable.

## Why This Stack Works

The synergy between NestJS and Next.js goes beyond both being TypeScript frameworks. They share similar philosophies around structure, conventions, and developer experience while solving different problems beautifully.

### NestJS: The Backend Powerhouse

NestJS brings enterprise-grade architecture patterns to Node.js. Its dependency injection system, modular structure, and decorator-based approach make it easy to build scalable APIs:

```typescript
// auth.controller.ts
@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly jwtService: JwtService
  ) {}

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() loginDto: LoginDto) {
    const user = await this.authService.validateUser(
      loginDto.email,
      loginDto.password
    );

    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    return {
      access_token: this.jwtService.sign({
        sub: user.id,
        email: user.email
      })
    };
  }
}
```

### Next.js: The Frontend Framework

Next.js provides server-side rendering, static generation, and API routes out of the box. For the EMA project at Servant, we leveraged Next.js's App Router for an optimized user experience:

```typescript
// app/dashboard/page.tsx
import { DashboardStats } from '@/components/dashboard-stats';
import { authOptions } from '@/lib/auth';
import { getServerSession } from 'next-auth';

export default async function DashboardPage() {
  const session = await getServerSession(authOptions);

  // Fetch data on the server
  const stats = await fetch(
    `${process.env.API_URL}/stats`,
    {
      headers: {
        Authorization: `Bearer ${session?.accessToken}`
      }
    }
  ).then(res => res.json());

  return (
    <main className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Dashboard</h1>
      <DashboardStats data={stats} />
    </main>
  );
}
```

## Shared TypeScript Types

One of the biggest advantages is sharing type definitions between frontend and backend. I typically structure this with a shared types package:

```typescript
// shared/types/user.types.ts
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}

export enum UserRole {
  ADMIN = 'admin',
  COORDINATOR = 'coordinator',
  ADVOCATE = 'advocate',
  MOTHER = 'mother'
}

export interface CreateUserDto {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}
```

These types are imported in both the NestJS backend and Next.js frontend, ensuring type safety across the entire application.

## API Documentation with Swagger

NestJS makes API documentation trivial with Swagger integration:

```typescript
// main.ts
const config = new DocumentBuilder()
  .setTitle('EMA Portal API')
  .setDescription('API for advocates, coordinators, and mothers')
  .setVersion('1.0')
  .addBearerAuth()
  .build();

const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api/docs', app, document);
```

This auto-generated documentation became essential for frontend developers to understand available endpoints.

## Deployment Strategy

For the Servant project, we used Railway for deployment, which made it simple to deploy both applications:

- NestJS API as a separate service
- Next.js portal as another service
- PostgreSQL database as a third service

All connected through environment variables and internal networking.

## Key Benefits

After building multiple projects with this stack, the benefits are clear:

1. **End-to-end type safety**: TypeScript across the entire stack reduces bugs significantly
2. **Excellent DX**: Both frameworks have outstanding developer experiences
3. **Scalability**: The modular architecture of both frameworks makes scaling straightforward
4. **Rich ecosystems**: Massive communities and plugin ecosystems
5. **Performance**: Both frameworks are optimized for production use

## Conclusion

The NestJS + Next.js combination has become my go-to for enterprise applications. The shared language, similar architectural patterns, and excellent tooling create a productive environment that scales from small projects to large enterprise systems.

If you're building a new full-stack TypeScript application, give this combination serious consideration. The investment in learning both frameworks pays dividends in productivity and maintainability.
